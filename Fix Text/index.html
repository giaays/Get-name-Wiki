<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C√¥ng c·ª• s·ª≠a l·ªói encoding & Watermark</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2d3748;
        }
        
        textarea, input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }
        
        textarea {
            min-height: 150px;
        }
        
        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .buttons {
            text-align: center;
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .clear-btn {
            background: linear-gradient(45deg, #e53e3e, #c53030);
        }
        
        .copy-btn {
            background: linear-gradient(45deg, #38a169, #2f855a);
        }
        
        .watermark-btn {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
        }
        
        .status {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            font-weight: 600;
        }
        
        .success {
            background: #c6f6d5;
            color: #2f855a;
            border: 1px solid #9ae6b4;
        }
        
        .info {
            background: #bee3f8;
            color: #2b6cb0;
            border: 1px solid #90cdf4;
        }
        
        .watermark-section {
            background: #fff7ed;
            border: 2px solid #fed7aa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .watermark-section h3 {
            color: #c05621;
            margin-top: 0;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px 0;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            font-weight: normal;
            cursor: pointer;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        
        .hint {
            font-size: 12px;
            color: #718096;
            font-style: italic;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>C√¥ng c·ª• s·ª≠a l·ªói encoding & Watermark</h1>
        
        <div class="input-group">
            <label for="input">Nh·∫≠p vƒÉn b·∫£n c·∫ßn s·ª≠a:</label>
            <textarea id="input" placeholder="D√°n vƒÉn b·∫£n c√≥ l·ªói encoding v√†o ƒë√¢y..."></textarea>
        </div>
        
        <div class="buttons">
            <button onclick="fixText()">S·ª≠a l·ªói encoding</button>
            <button onclick="clearText()" class="clear-btn">X√≥a</button>
            <button onclick="copyResult()" class="copy-btn">Copy k·∫øt qu·∫£</button>
        </div>
        
        <div class="input-group">
            <label for="output">K·∫øt qu·∫£ sau khi s·ª≠a:</label>
            <textarea id="output" readonly placeholder="K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y..."></textarea>
        </div>
        
        <!-- WATERMARK SECTION -->
        <div class="watermark-section">
            <h3>Watermark</h3>
            
            <div class="input-group">
                <label for="watermark-text">N·ªôi dung watermark:</label>
                <input type="text" id="watermark-text" placeholder="VD: B·∫£n quy·ªÅn thu·ªôc v·ªÅ ABC" value="Ngu·ªìn: T√†i li·ªáu n·ªôi b·ªô">
            </div>
            
            <div class="input-group">
                <label for="watermark-count">S·ªë l∆∞·ª£ng watermark:</label>
                <input type="number" id="watermark-count" min="1" max="50" value="5" style="width: 100px;">
            </div>
            
            <div class="buttons">
                <button onclick="addWatermark()" class="watermark-btn">Th√™m Watermark</button>
            </div>
        </div>
        
        <div id="status"></div>
        
        <div id="changes-log" style="display: none;">
            <div class="input-group">
                <label>Chi ti·∫øt thay ƒë·ªïi:</label>
                <div id="changes-content" style="background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; padding: 15px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 14px;"></div>
            </div>
        </div>
    </div>

    <script>
        // B·∫£n ƒë·ªì c√°c k√Ω t·ª± b·ªã l·ªói encoding
        const charMap = {
            '‚ºâ': 'ÂÑø', '‚ªù': 'È£ü', '‚º¶': 'Â≠ê', '‚ªî': 'Èó®', '‚Ω§': 'Áî®', '‚ΩÖ': 'Êñπ', '‚ºú': 'Âèà', '‚ºÄ': '‰∏Ä',
            '‚ºó': 'ÂçÅ', '‚º§': 'Â§ß', '‚ºà': '‰∫∫', '‚ºä': 'ÂÖ•', '‚ºã': 'ÂÖ´', '‚ºí': 'Âäõ', '‚ºë': 'ÂàÄ', '‚º•': 'Â•≥',
            '‚º©': 'Â∞è', '‚ºØ': 'Â∑•', '‚º∞': 'Â∑±', '‚º±': 'Â∑æ', '‚º≤': 'Âπ≤', '‚º¥': 'Âπø', '‚º∏': 'Âºì', '‚ºº': 'ÂøÉ',
            '‚ºø': 'Êâã', '‚ΩÄ': 'ÊîØ', '‚ΩÇ': 'Êñá', '‚Ωá': 'Êó•', '‚Ωâ': 'Êúà', '‚Ωä': 'Êú®', '‚Ωî': 'Ê∞¥', '‚Ωï': 'ÁÅ´',
            '‚Ωó': 'Áà∂', '‚Ωö': 'Áâá', '‚Ωõ': 'Áâô', '‚Ωú': 'Áâõ', '‚Ωù': 'Áä¨', '‚Ωü': 'Áéâ', '‚Ω°': 'Áì¶', '‚Ω¢': 'Áîò',
            '‚Ω£': 'Áîü', '‚Ω•': 'Áî∞', '‚Ω©': 'ÁôΩ', '‚Ω™': 'ÁöÆ', '‚Ω´': 'Áöø', '‚Ω¨': 'ÁõÆ', '‚ΩØ': 'Áü≥', '‚Ω∞': 'Á§∫',
            '‚Ω≤': 'Á¶æ', '‚Ω≥': 'Á©¥', '‚Ω¥': 'Á´ã', '‚Ωµ': 'Á´π', '‚Ω∂': 'Á±≥', '‚Ω∑': 'Á≥∏', '‚Ωπ': 'ÁΩë', '‚Ω∫': 'Áæä',
            '‚Ωª': 'ÁæΩ', '‚Ωº': 'ËÄÅ', '‚ΩΩ': 'ËÄå', '‚Ωø': 'ËÄ≥', '‚æÅ': 'ËÇâ', '‚æÇ': 'Ëá£', '‚æÉ': 'Ëá™', '‚æÑ': 'Ëá≥',
            '‚æÜ': 'Ëàå', '‚æà': 'Ëàü', '‚æä': 'Ëâ≤', '‚æç': 'Ëô´', '‚æé': 'Ë°Ä', '‚æè': 'Ë°å', '‚æê': 'Ë°£', '‚æì': 'Ëßí',
            '‚æî': 'Ë®Ä', '‚æï': 'Ë∞∑', '‚æñ': 'Ë±Ü', '‚æô': 'Ë¥ù', '‚æö': 'Ëµ§', '‚æõ': 'Ëµ∞', '‚æú': 'Ë∂≥', '‚æù': 'Ë∫´',
            '‚æû': 'ËΩ¶', '‚æü': 'Ëæõ', '‚æ®': 'Èó®', '‚æ¶': 'Èáë', '‚æß': 'Èïø', '‚æ¨': 'Èõ®', '‚æÆ': 'Èùû', '‚æØ': 'Èù¢',
            '‚æ∑': 'È£ü', '‚æ∏': 'È¶ñ', '‚æπ': 'È¶ô', '‚æª': 'È™®', '‚æº': 'È´ò', '‚æ•': 'Èáå', '‚ΩÜ': 'Êó†', '‚ª¢': 'È©¨',
            '‚ªÖ': 'ËßÅ', '‚ªÜ': 'Ëßí', '‚ª©': 'ÈªÑ'
        };

        // ======= WATERMARK FUNCTIONS =======
        
        // B·∫£n ƒë·ªì Homoglyphs (k√Ω t·ª± tr√¥ng gi·ªëng nhau)
        const homoglyphs = {
            'a': ['–∞', '·∫°', 'Œ¨', 'Œ±', 'ÔΩÅ'],  // Latin a vs Cyrillic –∞ vs Greek Œ±
            'e': ['–µ', '“Ω', '–µÃÅ', '·∫ø', 'ÔΩÖ'],  // Latin e vs Cyrillic –µ
            'o': ['–æ', 'Œø', 'Œø', '·ªç', 'ÔΩè'],  // Latin o vs Cyrillic –æ vs Greek Œø
            'c': ['—Å', 'œ≤', '‚ÖΩ', 'ÔΩÉ'],       // Latin c vs Cyrillic —Å
            'i': ['—ñ', 'ƒ±', '…™', '·ªã', 'ÔΩâ'],  // Latin i vs various
            'u': ['œÖ', '’Ω', '·ª•', 'ÔΩï'],       // Latin u vs Greek œÖ
            'p': ['—Ä', 'œÅ', 'ÔΩê'],            // Latin p vs Cyrillic —Ä
            'n': ['–ø', '’∏', 'ÔΩé'],            // Latin n vs Cyrillic –ø
            'B': ['–í', 'Œí', 'Ôº¢'],            // Latin B vs Cyrillic –í
            'T': ['–¢', 'Œ§', 'Ôº¥'],            // Latin T vs Cyrillic –¢
            'N': ['Œù', 'Œù', 'ÔºÆ'],            // Latin N vs Greek Œù
            'g': ['÷Å', '…°', 'ÔΩá'],
            'h': ['“ª', '’∞', 'ÔΩà'],
            'l': ['”Ä', 'Ôºë', 'ÔΩå'],
            's': ['—ï', 'ÔΩì'],
            'y': ['—É', 'ÔΩô'],
        };
        
        // Zero-width characters
        const zeroWidth = {
            zwj: '\u200D',     // Zero Width Joiner
            zwnj: '\u200C',    // Zero Width Non-Joiner
            zwsp: '\u200B',    // Zero Width Space
            lrm: '\u200E',     // Left-to-Right Mark
            rlm: '\u200F',     // Right-to-Left Mark
        };
        
        // Combining diacritical marks (d·∫•u ti·∫øng Vi·ªát r·ªùi)
        const combiningMarks = {
            acute: '\u0301',   // d·∫•u s·∫Øc
            grave: '\u0300',   // d·∫•u huy·ªÅn
            hook: '\u0309',    // d·∫•u h·ªèi
            tilde: '\u0303',   // d·∫•u ng√£
            dot: '\u0323',     // d·∫•u n·∫∑ng
        };
        
        // Unicode variation selectors
        const variations = ['\uFE00', '\uFE01', '\uFE02', '\uFE0E', '\uFE0F'];
        
        // Invisible separators (k√Ω t·ª± ph√¢n c√°ch v√¥ h√¨nh)
        const invisibleSeparators = [
            '\u2060', // Word Joiner
            '\u2063', // Invisible Separator
            '\uFEFF', // Zero Width No-Break Space (BOM)
            '\u180E', // Mongolian Vowel Separator
        ];
        
        // Load saved watermark text
        function loadWatermarkText() {
            const saved = localStorage.getItem('watermarkText');
            if (saved) {
                document.getElementById('watermark-text').value = saved;
            }
        }
        
        // Save watermark text
        function saveWatermarkText(text) {
            localStorage.setItem('watermarkText', text);
        }
        
        function encodeWatermark(text) {
            let encoded = text;
            
            // 1. Apply Homoglyphs (100% √°p d·ª•ng)
            encoded = encoded.split('').map(char => {
                const lower = char.toLowerCase();
                if (homoglyphs[lower] && Math.random() > 0.2) {
                    const variants = homoglyphs[lower];
                    const chosen = variants[Math.floor(Math.random() * variants.length)];
                    return char === char.toUpperCase() ? chosen.toUpperCase() : chosen;
                }
                return char;
            }).join('');
            
            // 2. Add Zero-width characters
            const zwChars = Object.values(zeroWidth);
            encoded = encoded.split('').map((char, i) => {
                if (i > 0 && Math.random() > 0.5) {
                    const zw = zwChars[Math.floor(Math.random() * zwChars.length)];
                    return zw + char;
                }
                return char;
            }).join('');
            
            // 3. Add Combining marks (d·∫•u r·ªùi)
            const marks = Object.values(combiningMarks);
            encoded = encoded.split('').map((char, i) => {
                if (/[aeiouAEIOU]/.test(char) && Math.random() > 0.4) {
                    const mark = marks[Math.floor(Math.random() * marks.length)];
                    return char + mark;
                }
                return char;
            }).join('');
            
            // 4. Add Unicode variations
            encoded = encoded.split('').map((char, i) => {
                if (Math.random() > 0.6) {
                    const variant = variations[Math.floor(Math.random() * variations.length)];
                    return char + variant;
                }
                return char;
            }).join('');
            
            // 5. Add Invisible separators (PH∆Ø∆†NG TH·ª®C M·ªöI)
            encoded = encoded.split('').map((char, i) => {
                if (i > 0 && i < encoded.length - 1 && Math.random() > 0.7) {
                    const sep = invisibleSeparators[Math.floor(Math.random() * invisibleSeparators.length)];
                    return char + sep;
                }
                return char;
            }).join('');
            
            // 6. Add random whitespace variations (PH∆Ø∆†NG TH·ª®C M·ªöI)
            // Thay th·∫ø kho·∫£ng tr·∫Øng th√¥ng th∆∞·ªùng b·∫±ng c√°c lo·∫°i space Unicode kh√°c
            const spaceVariations = [
                '\u0020', // Normal space
                '\u00A0', // Non-breaking space
                '\u2002', // En space
                '\u2003', // Em space
                '\u2009', // Thin space
                '\u200A', // Hair space
            ];
            encoded = encoded.split(' ').map((word, i) => {
                if (i > 0) {
                    const space = spaceVariations[Math.floor(Math.random() * spaceVariations.length)];
                    return space + word;
                }
                return word;
            }).join('');
            
            return encoded;
        }
        
        function addWatermark() {
            const output = document.getElementById('output');
            const watermarkText = document.getElementById('watermark-text').value.trim();
            const watermarkCount = parseInt(document.getElementById('watermark-count').value);
            
            if (!output.value.trim()) {
                showStatus('Vui l√≤ng x·ª≠ l√Ω vƒÉn b·∫£n tr∆∞·ªõc khi th√™m watermark', 'info');
                return;
            }
            
            if (!watermarkText) {
                showStatus('Vui l√≤ng nh·∫≠p n·ªôi dung watermark', 'info');
                return;
            }
            
            // Save watermark text for next time
            saveWatermarkText(watermarkText);
            
            // T√°ch vƒÉn b·∫£n th√†nh c√°c ƒëo·∫°n
            const paragraphs = output.value.split('\n\n').filter(p => p.trim());
            
            if (paragraphs.length < 2) {
                showStatus('VƒÉn b·∫£n c·∫ßn c√≥ √≠t nh·∫•t 2 ƒëo·∫°n vƒÉn ƒë·ªÉ ch√®n watermark', 'info');
                return;
            }
            
            // Gi·ªõi h·∫°n s·ªë watermark kh√¥ng v∆∞·ª£t qu√° s·ªë ƒëo·∫°n vƒÉn - 1
            const maxWatermarks = paragraphs.length - 1;
            const actualCount = Math.min(watermarkCount, maxWatermarks);
            
            if (actualCount < watermarkCount) {
                showStatus(`VƒÉn b·∫£n ch·ªâ c√≥ ${paragraphs.length} ƒëo·∫°n, ch·ªâ c√≥ th·ªÉ ch√®n t·ªëi ƒëa ${maxWatermarks} watermark`, 'info');
            }
            
            // T·∫°o danh s√°ch v·ªã tr√≠ ng·∫´u nhi√™n ƒë·ªÉ ch√®n watermark
            const availablePositions = Array.from({length: maxWatermarks}, (_, i) => i + 1);
            
            // Shuffle v√† ch·ªçn actualCount v·ªã tr√≠ ng·∫´u nhi√™n
            const selectedPositions = [];
            for (let i = 0; i < actualCount; i++) {
                const randomIndex = Math.floor(Math.random() * availablePositions.length);
                selectedPositions.push(availablePositions[randomIndex]);
                availablePositions.splice(randomIndex, 1);
            }
            
            // S·∫Øp x·∫øp v·ªã tr√≠ ƒë·ªÉ ch√®n t·ª´ tr√™n xu·ªëng
            selectedPositions.sort((a, b) => a - b);
            
            // M√£ h√≥a watermark v·ªõi ƒë·ªô kh√°c nhau cho m·ªói l·∫ßn ch√®n
            let result = [];
            let watermarkIndex = 0;
            
            for (let i = 0; i < paragraphs.length; i++) {
                result.push(paragraphs[i]);
                
                // Ki·ªÉm tra xem sau ƒëo·∫°n n√†y c√≥ ch√®n watermark kh√¥ng
                if (watermarkIndex < selectedPositions.length && 
                    selectedPositions[watermarkIndex] === i + 1) {
                    
                    // M·ªói watermark ƒë∆∞·ª£c m√£ h√≥a kh√°c nhau (6 l·ªõp b·∫£o v·ªá)
                    const encodedWatermark = 'üíß ' + encodeWatermark(watermarkText) + ' üíß';
                    result.push(encodedWatermark);
                    watermarkIndex++;
                }
            }
            
            output.value = result.join('\n\n');
            
            showStatus(`ƒê√£ ch√®n ${actualCount} watermark v√†o vƒÉn b·∫£n`, 'success');
        }
        
        // ======= ORIGINAL FUNCTIONS =======
        
        function fixText() {
            const input = document.getElementById('input').value;
            const output = document.getElementById('output');
            const status = document.getElementById('status');
            const changesLog = document.getElementById('changes-log');
            const changesContent = document.getElementById('changes-content');
            
            if (!input.trim()) {
                showStatus('Vui l√≤ng nh·∫≠p vƒÉn b·∫£n c·∫ßn s·ª≠a!', 'info');
                changesLog.style.display = 'none';
                return;
            }
            
            let fixedText = input;
            let changesCount = 0;
            let changesList = [];
            
            // B∆Ø·ªöC 1: X√≥a k√Ω t·ª± th·ª´a theo regex
            const removeRegex = /[Tt≈§≈•·π™·π´·π¨·π≠·πÆ·πØ·π∞·π±≈¢≈£·∫ó≈¶≈ß∆≠∆¨»ö»õ≈§≈•·π¨·π≠·π∞·π±][Uu√ö√∫√ô√π√õ√ª√ú√º≈®≈©≈™≈´≈¨≈≠≈Æ≈Ø≈≤≈≥·ª§·ª•·ª¶·ªß·π≤·π≥·π¥·πµ·π∂·π∑·π∏·ππ·π∫·πª≈∞≈±≈Æ≈Ø≈´ÃÅ≈≠≈≥][\u0300-\u036F]*[\u2070-\u209F‚ÇÄ-‚Çâ‚Çê‚Çë‚Çï·µ¢‚±º‚Çñ‚Çó‚Çò‚Çô‚Çí‚Çö·µ£‚Çõ‚Çú·µ§·µ•w‚Çì·µß·∂ª‚Å∞-‚Åπ¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ·µÉ-·∂ª‚Å∫‚Åª‚Åº‚ÅΩ‚Åæ‚Çä‚Çã‚Çå‚Çç‚Çé]+/g;
            
            let match;
            let removedCount = 0;
            
            while ((match = removeRegex.exec(input)) !== null) {
                removedCount++;
                const beforeMatch = input.substring(0, match.index);
                const lineNumber = beforeMatch.split('\n').length;
                const lineStart = beforeMatch.lastIndexOf('\n') + 1;
                const columnNumber = match.index - lineStart + 1;
                const start = Math.max(0, match.index - 5);
                const end = Math.min(input.length, match.index + match[0].length + 5);
                const context = input.substring(start, end);
                const contextHighlighted = context.replace(match[0], `<mark style="background: #ff5722; color: white; font-weight: bold;">${match[0]}</mark>`);
                
                changesList.push({
                    type: 'remove',
                    broken: match[0],
                    correct: '[X√ìA]',
                    line: lineNumber,
                    column: columnNumber,
                    context: contextHighlighted,
                    position: match.index
                });
                
                removeRegex.lastIndex = match.index + 1;
            }
            
            fixedText = fixedText.replace(/[Tt≈§≈•·π™·π´·π¨·π≠·πÆ·πØ·π∞·π±≈¢≈£·∫ó≈¶≈ß∆≠∆¨»ö»õ≈§≈•·π¨·π≠·π∞·π±][Uu√ö√∫√ô√π√õ√ª√ú√º≈®≈©≈™≈´≈¨≈≠≈Æ≈Ø≈≤≈≥·ª§·ª•·ª¶·ªß·π≤·π≥·π¥·πµ·π∂·π∑·π∏·ππ·π∫·πª≈∞≈±≈Æ≈Ø≈´ÃÅ≈≠≈≥][\u0300-\u036F]*[\u2070-\u209F‚ÇÄ-‚Çâ‚Çê‚Çë‚Çï·µ¢‚±º‚Çñ‚Çó‚Çò‚Çô‚Çí‚Çö·µ£‚Çõ‚Çú·µ§·µ•w‚Çì·µß·∂ª‚Å∞-‚Åπ¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ·µÉ-·∂ª‚Å∫‚Åª‚Åº‚ÅΩ‚Åæ‚Çä‚Çã‚Çå‚Çç‚Çé]+/g, '');
            changesCount += removedCount;
            
            // B∆Ø·ªöC 2: Thay th·∫ø c√°c k√Ω t·ª± b·ªã l·ªói encoding
            for (const [broken, correct] of Object.entries(charMap)) {
                const regex = new RegExp(broken, 'g');
                let matchChar;
                
                while ((matchChar = regex.exec(fixedText)) !== null) {
                    changesCount++;
                    const beforeMatch = fixedText.substring(0, matchChar.index);
                    const lineNumber = beforeMatch.split('\n').length;
                    const lineStart = beforeMatch.lastIndexOf('\n') + 1;
                    const columnNumber = matchChar.index - lineStart + 1;
                    const start = Math.max(0, matchChar.index - 5);
                    const end = Math.min(fixedText.length, matchChar.index + 6);
                    const context = fixedText.substring(start, end);
                    const contextHighlighted = context.replace(broken, `<mark style="background: #ffeb3b; color: #d32f2f; font-weight: bold;">${broken}</mark>`);
                    
                    changesList.push({
                        type: 'replace',
                        broken: broken,
                        correct: correct,
                        line: lineNumber,
                        column: columnNumber,
                        context: contextHighlighted,
                        position: matchChar.index
                    });
                    
                    regex.lastIndex = matchChar.index + 1;
                }
                
                fixedText = fixedText.replace(new RegExp(broken, 'g'), correct);
            }
            
            output.value = fixedText;
            
            if (changesCount > 0) {
                changesList.sort((a, b) => {
                    if (a.type !== b.type) {
                        return a.type === 'remove' ? -1 : 1;
                    }
                    return a.position - b.position;
                });
                
                let changesHtml = `<div style="margin-bottom: 10px;"><strong>T·ªïng c·ªông: ${changesCount} thay ƒë·ªïi (${removedCount} x√≥a, ${changesCount - removedCount} thay th·∫ø)</strong></div>`;
                
                changesList.forEach((change, index) => {
                    const isRemove = change.type === 'remove';
                    const bgColor = isRemove ? '#ffebee' : '#e3f2fd';
                    const borderColor = isRemove ? '#f44336' : '#667eea';
                    const actionIcon = isRemove ? 'X√ìA' : 'THAY';
                    
                    changesHtml += `
                        <div style="border-left: 3px solid ${borderColor}; padding-left: 10px; margin-bottom: 10px; background: ${bgColor}; border-radius: 0 5px 5px 0;">
                            <div style="color: #666; font-size: 12px; margin-bottom: 5px;">
                                ${actionIcon} #${index + 1} ‚Ä¢ D√≤ng ${change.line}, c·ªôt ${change.column}
                            </div>
                            <div style="margin-bottom: 5px;">
                                <span style="color: ${isRemove ? '#d32f2f' : '#d32f2f'}; background: ${isRemove ? '#ffcdd2' : '#ffebee'}; padding: 2px 6px; border-radius: 3px; font-weight: bold;">${change.broken}</span>
                                <span style="margin: 0 8px; color: #666;">‚Üí</span>
                                <span style="color: ${isRemove ? '#d32f2f' : '#2e7d32'}; background: ${isRemove ? '#ffcdd2' : '#e8f5e8'}; padding: 2px 6px; border-radius: 3px; font-weight: bold;">${change.correct}</span>
                            </div>
                            <div style="color: #555; font-size: 13px;">
                                <strong>Context:</strong> ${change.context}
                            </div>
                        </div>
                    `;
                });
                
                changesContent.innerHTML = changesHtml;
                changesLog.style.display = 'block';
                
                showStatus(`ƒê√£ x·ª≠ l√Ω ${changesCount} thay ƒë·ªïi (${removedCount} x√≥a k√Ω t·ª± th·ª´a, ${changesCount - removedCount} s·ª≠a encoding)`, 'success');
            } else {
                changesLog.style.display = 'none';
                showStatus('Kh√¥ng t√¨m th·∫•y k√Ω t·ª± n√†o c·∫ßn s·ª≠a', 'info');
            }
        }
        
        function clearText() {
            document.getElementById('input').value = '';
            document.getElementById('output').value = '';
            document.getElementById('status').innerHTML = '';
            document.getElementById('changes-log').style.display = 'none';
        }
        
        function copyResult() {
            const output = document.getElementById('output');
            if (!output.value.trim()) {
                showStatus('Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ copy!', 'info');
                return;
            }
            
            output.select();
            output.setSelectionRange(0, 99999);
            
            try {
                document.execCommand('copy');
                showStatus('ƒê√£ copy k·∫øt qu·∫£ v√†o clipboard', 'success');
            } catch (err) {
                navigator.clipboard.writeText(output.value).then(() => {
                    showStatus('ƒê√£ copy k·∫øt qu·∫£ v√†o clipboard', 'success');
                }).catch(() => {
                    showStatus('Kh√¥ng th·ªÉ copy. Vui l√≤ng copy th·ªß c√¥ng', 'info');
                });
            }
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.innerHTML = message;
            status.className = `status ${type}`;
            
            setTimeout(() => {
                status.innerHTML = '';
                status.className = '';
            }, 3000);
        }
        
        // Auto-fix when typing (debounced)
        document.getElementById('input').addEventListener('input', function() {
            clearTimeout(this.timeout);
            this.timeout = setTimeout(() => {
                if (this.value.trim()) {
                    fixText();
                }
            }, 500);
        });
        
        // Load saved watermark text when page loads
        window.addEventListener('DOMContentLoaded', function() {
            loadWatermarkText();
        });
        
        // Save watermark text when it changes
        document.getElementById('watermark-text').addEventListener('input', function() {
            saveWatermarkText(this.value);
        });
    </script>
</body>
</html>
